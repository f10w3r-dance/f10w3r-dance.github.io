---
layout: post
date: 2020-12-21
title: "2020년 11월 PlugX 분석 이야기 2편(Stage1 분석)"
author: "f10w3r"
tags: malware apt41 plugx
---

[2020년 11월 PlugX 분석 이야기 1편(샘플 확보) 보러 가기](PlugX-1.md)

지난 시간에 이어 샘플 확보를 완료했습니다. 이제 본격적인 분석을 시작해보죠!

이전글에서 확인했지만, `C4164EFA57204AD32AEC2B0F1A12BB3A` 샘플은 `license.rtf` 파일을 읽어 메모리상에서 쉘코드를 실행하는 구조를 가지고 있는 악성코드 입니다.(아래 그림을 참고해주세요.)

![pic1](pic/ida_screen.png?raw=true)


일단 APT41은 기본적으로 쉘코드를 매우 사랑하는 조직인듯 합니다.(글쓴이 피셜) 이 그룹을 분석할 때면, 항상 분석하기가 싫군요 ㅎㅎ..

![pic2](pic/fuckingshellcode.jpg?raw=true)


제일 먼저 `C4164EFA57204AD32AEC2B0F1A12BB3A` 악성코드는 `license.rtf`의 데이터를 읽어와 `VirtualAlloc` 함수를 통해 실행 가능한 메모리를 할당 받고 데이터를 읽어옵니다.

![pic3](pic/스크린샷%202020-12-20%20오후%2010.39.37.png?raw=true)


그리고는 무자비하게도 뒤도 안돌아보고 바로 쉘코드로 점프 해버립니다.

![pic4](pic/스크린샷%202020-12-20%20오후%2010.42.06.png?raw=true)


방금 분석으로 우리는 무려 당연하지만 중요한 2가지 정보를 얻었습니다! 

1. 쉘코드는 맨 처음부터 실행된다.
2. license.rtf 파일은 암호화 혹은 인코딩 되어있지 않았을것이다.

따라서 재빨리 `license.rtf` 파일을 분석 해보겠습니다.

제일 먼저 `license.rtf`를 IDA를 통해 확인해보면 예쁜 hex-ray가 우리를 기다려주고 있을겁니다.

![pic5](pic/스크린샷%202020-12-20%20오후%2011.28.15.png)


... 후...

![pic6](pic/fuckingshellcode.jpg?raw=true)


마음을 진정시키고 차근차근 분석 해보겠습니다. 여러분도 진정하세요..!

제일 먼저 눈에 들어오는건 이 부분입니다.
```asm
push    12CF1h
call    near ptr dword_1283C+4BFh
```

전 제일 먼저 인자로 들어가는 `push    12CF1h` 이 부분이 수상해 보였습니다. 

`f10w3r: 동작 그만, 밑장 깔기냐? 너는 지금 오프셋을 스택에다 깔았어 그리고 코드 밑에 정상적인 ret이 없는걸 보니까 call 안에서 함수 프롤로그 따위는 없는거 겠지 그럼 너는 call 호출시에 스택에 깔리는 다음 instruction의 주소에 니가 넣어준 오프셋을 더해서 뭔가 조잡한짓을 할것이야 내가 빙다리 핫바지로 보이냐 이 새끼야?`

![pic7](pic/밑장빼기냐.jpeg)


이어서 호출되는 `call near ptr dword_1283C+4BFh`는 아래와 같습니다.

![pic8](pic/스크린샷%202020-12-20%20오후%2011.37.55.png)

역시 함수 프롤로그는 없군요 방금전과 같은 방식으로 인자를 하나 더 설정하고 다음 `sub_14211`을 호출 합니다.

`sub_14211` 함수를 보기전 `sub_14211` 함수 호출 직후 잠시 잠시 스택 상황을 먼저 그려보면 아래와 같을겁니다.

|스택(아래가 높은 주소|
|------|
|12D05h(call 다음 ins)|
|150Ch(push로 넣은 값)|
|0Ah(call다음 ins)|
|12CF1h(push로 넣은 값)|


이렇게 스택 구조를 기억해 놓은 뒤 `sub_14211`를 확인해보면 내부에서 함수 `sub_14217`를 호출하고 정상적으로 `return`하는 모습을 확인할 수 있습니다.

```
seg000:00014211 sub_14211       proc near               ; CODE XREF: seg000:00012D00↑p
seg000:00014211                 call    sub_14217
seg000:00014216                 retn
seg000:00014216 sub_14211       endp ; sp-analysis failed
```

 `sub_14217` 함수 내부로 들어 가보면, 정상적으로 함수 프롤로그를 실행하는것을 확인할 수 있으며, 이는 다시 말해 위에서 `push`와 `call`로 스택에 넣은 값들이 `sub_14217`의 인자로 설정된 것을 예상 할 수 있습니다. 해당 함수의 경우 정상적인 구조를 가지고 있기 떄문에 함수로 인식되어 IDA에서 hex-ray 코드로 변환이 가능합니다.

 ![pic9](./pic/스크린샷%202020-12-20%20오후%2011.46.45.png)


그리고는 `fs:[0x30]` 에 접근하여 **Process Environment Block**을 가져와 `kernel32.dll`에 존재하는 `GetProcAddress` 함수의 맵핑된 주소를 가져옵니다.

![pic10](./pic/스크린샷%202020-12-20%20오후%2011.51.04.png)


이후 `GetProcAddress`함수를 통해 악성코드 내부에서 사용할 함수의 맵핑된 주소를 가져옵니다. 

이 자식, 생각보다 착한 놈이였습니다. 가져오는 함수를 해시화 시키지 않다니.. 하마터면 스크립트 코딩 해야하는줄 알고 긴장했습니다..

![pic11](./pic/스크린샷%202020-12-20%20오후%2011.54.03.png)

